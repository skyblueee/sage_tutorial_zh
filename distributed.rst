*********************
分布式计算
*********************

Sage内置了强大的分布式计算框架“分布式Sage”(``dsage``).

概要
========

分布式Sage是一个框架，允许用户在Sage中进行分布式计算。
它包括一个服务器，客户端和若干计算节点，以及可编写计算任务的类。
它被设计成主要用于粗糙的分布式计算，即，任务之间联系不多的计算。
有时候也被称为网格计算。

分布式Sage由3个部分组成：


#. **服务器** 的职责是任务的分配，提交和收集。
   还包括一个web接口，以便于监视计算任务和进行其他管理的工作。

#. **客户端** 的职责是提交新的任务给服务器并收集计算结果。

#. **计算节点** 执行实际的计算。

快速入门
===========

这有几个例子展示如何使用 ``dsage``.

例 1
---------


#. 运行 ``dsage.setup()``. 将设置SQLite数据库并为SSL通信生成公钥和私钥。
   还根据你当前的用户名添加一个默认的用户。

#. 运行 ``d = dsage.start_all()``. 该命令启动服务器，web服务器，
   :math:`2` 个计算节点，并返回一个对象(``d``)，它是一个与服务器的连接。
   从这儿开始，你与 ``dsage`` 的交互任务主要通过 ``d`` 来完成。

#. 打开浏览器，转到 http://localhost:8082 查看 ``dsage`` 的web界面。
   在这里你可以看到计算任务的状态，计算节点的连接以及 ``dsage``
   服务器的其他一些重要信息。(译注：在我的机子上，
   每次的端口号都不一样，似乎也没有规律。可以使用 nc -zv localhost 1-65535
   命令查看当前所有打开的端口，挨个尝试。)

#. 尝试一个简单的例子。输入 ``job=d('2+2')``. 如果你看着Web界面，
   会看到表格中出现一个新的任务。现在一个计算节点接受这个任务，
   执行后将结果显示给你。要得到结果，输入 ``job.result``. 
   可能现在还没有结果，因为对于简单的计算，网络通信占用了大量的计算时间。
   如果你希望等待你的任务结束，可以调用 ``job.wait()``, 
   这将阻断通信直到任务完成，那时可以用 ``job.result`` 查看结果。
   你可以用这种方法调用 ``d`` 进行任何的计算。


例2
---------

在这个例子中，我们演示如何使用 ``dsage`` 的内置类 ``DistributedFactor``.
DistributedFactor混合使用ECM和QSieve算法进行因子分解，
对小的因子进行试验分解。


#. 如果还没有启动 ``dsage`` 会话，就运行 ``d = dsage.start_all()``,
   否则可以接着使用之前的 ``d`` 实例。

#. 使用 ``factor_job = DistributedFactor(d, number)`` 启动分布式分解任务。
   你可以选一个相当大的值，比如 :math:`2^{360}-1`.
   可以检查 ``factor_job.done`` 属性来查看分解任务是否已经完成。
   如果已经完成，可以使用 ``factor_job.prime_factors`` 查看它找到的素因子。

例3
---------

这个例子演示分布式的 ``map`` 方法。你可以在
http://docs.python.org/lib/build-in-funcs.html 找到关于正规
``map`` 方法的文档。语法是完全相同的。

首先，如果还没有启动 ``dsage`` 会话，就运行 ``d = dsage.start_all()``,
否则可以接着使用之前的 ``d`` 实例。

.. skip

::

    sage: def f(n): return n*n
    sage: j = d.map(f, [25,12,25,32,12])
    sage: jobs = d.block_on_jobs(j)

这将堵断通信直到 ``f`` 对每一个输入都运算完毕。

例4
---------

这个例子演示如何对一个 ``dsage`` 实例使用 ``@parallel`` 修饰。

首先，如果还没有启动 ``dsage`` 会话，就运行 ``d = dsage.start_all()``,
否则可以接着使用之前的 ``d`` 实例。

.. skip

::

    sage: P = parallel(p_iter = d.parallel_iter)
    sage: @P
    ...   def f(n,m):  return n+m
    sage: f([(1,2), (5, 10/3)])



文件
=====

``dsage`` 将新文件保存在 ``$SAGE_ROOT/.sage/dsage``:


#. ``pubcert.pem`` 和 ``cacert.pem``: 用于SSL通信的公钥和私钥。

#. ``dsage_key.pub`` 和 ``dsage_key``: 用于用户授权的密钥。

#. 目录 ``db/``: 包含 ``dsage`` 的数据库。

#. ``*.log`` 文件: 由服务器和计算节点生成的日志文件。

#. 目录 ``tmp_worker_files/``: 计算节点在计算时，将任务保存在这里。

